<?php

namespace Tests\Feature;

use Illuminate\Database\Query\Builder;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Tests\TestCase;
use function PHPUnit\Framework\assertNotNull;

class QueryBuilderTest extends TestCase
{
    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        DB::delete("delete from products");
        DB::delete("delete from categories");
    }

    /**
     * Query Builder
     * ● Selain menggunakan Raw Sql, Laravel Database juga memiliki fitur bernama Query Builder
     * ● Fitur ini sangat mempermudah kita ketika ingin membuat perintah ke database dibandingkan
     *   melakukannya secara manual menggunakan Raw SQL
     * ● Query Builder direpresentasikan dengan class Builder
     * ● https://laravel.com/api/10.x/Illuminate/Database/Query/Builder.html
     * ● Untuk membuat Query Builder, kita bisa gunakan function DB::table(nama)
     *
     * Query Builder Insert
     * ● Untuk melakukan Insert menggunakan Query Builder, kita bisa menggunakan method dengan
     *   prefix insert dengan parameter associative array dimana key nya adalah kolom, dan value nya
     *   adalah nilai yang akan disimpan di database
     * ● insert() untuk memasukkan data ke database, throw exception jika terjadi error misal duplicate
     *   primary key
     * ● insertGetId() untuk memasukkan data ke database, dan mengembalikan primary key yang diset
     *   secara auto generate, cocok untuk tabel dengan id auto increment
     * ● insertOrIgnore() untuk memasukkan data ke database, dan jika terjadi error, maka akan di ignore
     */

    public function testQueryBuilderInsert(){

        // DB::table("nama_table")->insert(["key" => value]) // key adalah nama column dan value ada isi data record
        // sql: select count(id) as total from categories
        DB::table("categories")->insert([
            "id" => "SANDAL",
            "name" => "Consina",
            "description" => "Sandal Gunung",
        ]);
        DB::table("categories")->insert([
            "id" => "JAKET",
            "name" => "Consina",
            "description" => "Jaket Gunung",
        ]);

        $result = DB::select("select count(id) as total from categories");

        self::assertEquals(2, $result[0]->total);

        var_dump($result);

    }

    /**
     * Query Builder Select
     * ● Ada beberapa function di Query Builder yang bisa kita gunakan untuk melakukan perintah select
     * ● select(columns), untuk mengubah select kolom, dimana defaultnya adalah semua kolom
     * ● Setelah itu, untuk mengeksekusi SQL dan menyimpannya di Collection secara langsung, kita bisa
     *   menggunakan beberapa method
     * ● get(columns), untuk mengambil seluruh data, defaultnya semua kolom diambil
     * ● first(columns), untuk mengambil data pertama, defaultnya semua kolom diambil
     * ● pluck(column), untuk mengambil salah satu kolom saja
     * ● Hasil dari Query Builder Select adalah Laravel Collection
     */

    public function testQueryBuilderSelect(){

        $this->testQueryBuilderInsert(); //insert data

        // DB::table("nama_table")->select([column_table])->get();
        // sql: select `id`, `name` from `categories`
        // untuk eksekusi query ada beberapa method get() ambil semua, first() ambil data pertama,   pluck() ambil beberpa data
        $collection = DB::table("categories")
            ->select(["id", "name"])
            ->get();

        self::assertNotNull($collection);

        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

    }

    public function testInsertDataCategories(){

        DB::table("categories")->insert([
            "id" => "SANDAL",
            "name" => "Sandal",
            "description" => "",
            "created_at" => "2024-06-13 10:10:10"
        ]);
        DB::table("categories")->insert([
            "id" => "JAKET",
            "name" => "Jaket",
            "description" => "",
            "created_at" => "2024-06-13 10:10:10"
        ]);
        DB::table("categories")->insert([
            "id" => "TOPI",
            "name" => "Topi",
            "description" => "",
            "created_at" => "2024-06-13 10:10:10"
        ]);
        DB::table("categories")->insert([
            "id" => "CELANA",
            "name" => "Celana",
            "description" => "",
            "created_at" => "2024-06-13 10:10:10"
        ]);
    }

    /**
     * Query Builder Where
     * ● Sebelum kita lanjut ke materi Update dan Delete, kita harus tahu tentang Where di Query Builder
     * ● Untuk menambahkan Where di Query Builder, kita bisa menggunakan banyak sekali method
     *   dengan awalan where…()
     *
     * Where Method                                 Keterangan
     * where(column, operator, value)               AND column operator value
     * where([condition1, condition2])              AND (condition 1 AND condition 2 AND …)
     * where(callback(Builder))                     AND (condition)
     * orWhere(column, operator, value)             OR (condition)
     * orWhere(callback(Builder))                   OR (condition …)
     * whereNot(callback(Builder))                  NOT (condition …)
     */

    public function testWhere(){

        $this->testInsertDataCategories();

        // DB::table("nama_table")->where(callback(Builder))->get(); // select where bisa di dalam callback
        // sql: select * from `categories` where (`id` = ? or `id` = ?)
        $collection = DB::table("categories")->where(function(Builder $builder){
            $builder->where('id', '=', 'SANDAL');
            $builder->orWhere('id', '=', 'JAKET');
            // select * from categories where(id = SANDAL OR id = JAKET) // sql db
        })->get();

        self::assertCount(2, $collection);

        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     *  Where Between Method
     *  Where Method                                 Keterangan
     *  whereBetween(column, [value1, value2])       WHERE column BETWEEN value1 AND value2
     *  whereNotBetween(column, [value1,value2])     WHERE column NOT BETWEEN value1 AND value2
     */

    public function testWhereBetween(){

        $this->testInsertDataCategories();

        // DB::table("nama_table")->whereBetween(column, [record_column, record_column])->get(); // mengambil data dalam jangka waktu
        // sql: select * from `categories` where `created_at` between ? and ?
        $collection = DB::table("categories")
            ->whereBetween("created_at", ["2024-05-13 10:10:10", "2024-07-13 10:10:10"])
            ->get();

        self::assertCount(4, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     *   Where In Method
     *   Where Method                                 Keterangan
     *   whereIn(column, [array])                     WHERE column IN (array)
     *   whereNotIn(column, [array])                  WHERE column NOT IN (array)
     */
    public function testWhereIn(){

        $this->testInsertDataCategories();

        // DB::table("nama_table")->whereIn(column_table, ["record_column"])->get(); // select where id tertentu
        // sql: select * from `categories` where `id` in (?, ?)
        $collection = DB::table("categories")->
        whereIn("id", ["CELANA", "JAKET"])
            ->get();

        self::assertCount(2, $collection);

        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     *    Where Null Method
     *    Where Method                                 Keterangan
     *    whereNull(column)                            WHERE column IS NULL
     *    whereNotNull(column)                         WHERE column IS NOT NULL
     */
    public function testWhereNull(){

        $this->testInsertDataCategories();

        // DB::table("nama_table")->whereNull(column)->get(); // mengambil data yang column record nya null
        // sql: select * from `categories` where `description` is null
        $collection = DB::table("categories")
            ->whereNull("description")
            ->get();

        self::assertCount(0, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     *     Where Date Method
     *     Where Method                                 Keterangan
     *     whereDate(column, value)                     WHERE DATE(column) = value
     *     whereMonth(column, value)                    WHERE MONTH(column) = value
     *     whereDay(column, value)                      WHERE DAY(column) = value
     *     whereYear(column, value)                     WHERE YEAR(column) = value
     *     whereTime(column, value)                     WHERE TIME(column) = value
     */
    public function testWhereDate(){

        $this->testInsertDataCategories();

        // DB::table("nama_table")->whereNull(column)->get(); // mengambil data berdasarkan colum date
        // sql: select * from `categories` where date(`created_at`) = ?
        $collection = DB::table("categories")
            ->whereDate("created_at", "2024-06-13")
            ->get();

        self::assertCount(4, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     * Query Builder Update
     * ● Setelah kita tahu cara menggunakan Where, sekarang kita bahas tentang Update Method
     * ● Untuk melakukan Update, kita bisa menggunakan method update(array)
     * ● Dimana parameter nya kita bisa mengirim associative array yang berisi kolom -> value
     */

    public function testUpdate(){

        $this->testInsertDataCategories();

        // DB::table("name_table")->where("column", "operator", "record_column")->update(["column" => "record_column"])
        // sql: update `categories` set `name` = ? where `id` = ?
        DB::table("categories")
            ->where("id", "=", "CELANA")
            ->update(["name" => "BOXER"]);

        // sql: select * from `categories` where `name` = ?
        $collection = DB::table("categories")->where("name", "=", "BOXER")->get();

        self::assertCount(1, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     * Upsert (Update or Insert)
     * ● Query Builder menyediakan method untuk melakukan update or insert, dimana ketika mencoba
     *   melakukan update, jika datanya tidak ada, maka akan dilakukan insert data baru
     * ● Kita bisa menggunakan method updateOrInsert(attributes, values)
     */

    public function testUpsert(){

        // DB::table("name_table")->updateOrInsert(attributes[array_assosiative(select)], values[array_assosiative(yang mau di update)]);
        // sql: insert into `categories` (`id`, `name`, `description`, `created_at`) values (?, ?, ?, ?)
        DB::table("categories")
            ->updateOrInsert(
                [
                    "id" => "CELANA"
                ],
                [
                    "name" => "Jeans",
                    "description" => "Celana Pria",
                    "created_at" => "2024-05-13 10:10:10"
                ]);

        // sql: select * from `categories` where `id` = ?
        $collection = DB::table("categories")
            ->where("id", "=", "CELANA")
            ->get();

        self::assertCount(1, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     * Increment dan Decrement
     * ● Query Builder juga menyediakan cara mudah untuk melakukan increment atau decrement
     * ● Jadi kita tidak perlu melakukan increment atau decrement secara manual di kode PHP
     * ● Kita bisa menggunakan method
     * ● increment(column, increment) untuk melakukan increment
     * ● decrement(column, decrement) untuk melakukan decrement
     */

    public function testQueryBuilderIncrement(){

        // sql: update `counters` set `counter` = `counter` + 1 where `id` = ?
        DB::table("counters")
            ->where("id", "=", "sample")
            ->increment("counter", 1);

        // sql: select * from `counters` where `id` = ?
        $collection = DB::table("counters")
            ->where("id", "=" ,"sample")
            ->get();

        self::assertCount(1, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     * Query Builder Delete
     * ● Untuk melakukan delete, kita bisa menggunakan method
     * ● delete() untuk melakukan Sql DELETE, dan
     * ● truncate() untuk melakukan TRUNCATE table
     */

    public function testQueryBuilderDelete(){

        $this->testInsertDataCategories();

        // sql: delete from `categories` where `id` = ?
        DB::table("categories")
            ->where("id", "=", "CELANA")
            ->delete();

        // sql: select * from `categories` where `id` = ?
        $collection = DB::table("categories")
            ->where("id", "=", "CELANA")
            ->get();

        self::assertCount(0, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

    }

    /**
     * Query Builder Join
     * ● Query Builder juga menyediakan cara mudah untuk melakukan join, dengan menggunakan
     *   beberapa method
     * ● join(table, column, operator, ref_column) untuk JOIN atau INNER JOIN
     * ● leftJoin(table, column, operator, ref_column) untuk LEFT JOIN
     * ● rightJoin(table, column, operator, ref_column) untuk RIGHT JOIN
     * ● crossJoin(table, column, operator, ref_column) untuk CROSS JOIN
     */

    public function insertTableProduct(){

        $this->testInsertDataCategories();

        DB::table("products")->insert([
            "id" => "1",
            "name" => "Celana Eiger",
            "description" => "Celana Gunung Eiger",
            "price" => 100000,
            "category_id" => "CELANA",
        ]);

        DB::table("products")->insert([
            "id" => "2",
            "name" => "Celana Consina",
            "description" => "Celana Gunung Consina",
            "price" => 90000,
            "category_id" => "CELANA",
        ]);

    }

    public function testQueryBuilderJoin(){

        $this->insertTableProduct();

        // sql: select `products`.`id`, `products`.`name`, `categories`.`name` as `category_name`, `products`.`price` from `products` inner join `categories` on `products`.`category_id` = `categories`.`id`
        $collection = DB::table("products")
            ->join("categories", "products.category_id", "=", "categories.id")
            ->select("products.id", "products.name", "categories.name as category_name", "products.price") // select() // data apa saja yang mau di tampilkan // jika menggunakan alias, maka aliasnya yang di tampilkan
            ->get();

        self::assertCount(2, $collection);
        for ($i = 0; $i < $this->count($collection); $i++) {
            Log::info(json_encode($collection[$i]));
        }

        var_dump($collection);
        // result: {"id":"1","name":"Celana Eiger","category_name":"Celana","price":100000}

    }

    public function testQueryBuilderLeftJoin(){

        $this->insertTableProduct();

        // sql: select `products`.`id`, `products`.`name`, `categories`.`name` as `category_name`, `products`.`price` from `products` left join `categories` on `products`.`category_id` = `categories`.`id`
        $collection = DB::table("products")
            ->leftJoin("categories", "products.category_id", "=", "categories.id")
            ->select("products.id", "products.name", "categories.name as category_name", "products.price") // select() // data apa saja yang mau di tampilkan // jika menggunakan alias, maka aliasnya yang di tampilkan
            ->get();

        self::assertCount(2, $collection);
        for ($i = 0; $i < $this->count($collection); $i++) {
            Log::info(json_encode($collection[$i]));
        }

        var_dump($collection);
        // result: {"id":"1","name":"Celana Eiger","category_name":"Celana","price":100000}

    }

    /**
     * Query Builder Ordering
     * ● Query Builder juga memiliki method untuk memudahkan kita melakukan pengurutan data
     *   menggunakan
     * ● orderBy(column, order) dimana order bisa asc atau desc
     */

    public function testQueryBuilderOrdering(){

        $this->insertTableProduct();

        // sql: select * from `products` where `id` is not null order by `price` desc, `name` asc
        $collection = DB::table("products")
            ->whereNotNull("id")
            ->orderBy("price", "desc")
            ->orderBy("name", "asc")
            ->get();

        self::assertCount(2, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

        /**
         * result:
         * {"id":"1","name":"Celana Eiger","description":"Celana Gunung Eiger","price":100000,"category_id":"CELANA","created_at":"2024-06-13 17:22:39"}
         * {"id":"2","name":"Celana Consina","description":"Celana Gunung Consina","price":90000,"category_id":"CELANA","created_at":"2024-06-13 17:22:39"}
         */

    }

    /**
     * Query Builder Paging
     * ● Untuk melakukan paging, biasanya di SQL kita akan menggunakan perintah LIMIT OFFSET
     * ● Di Query Builder, kita bisa menggunakan method
     * ● take(number) untuk melakukan LIMIT
     * ● skip(number) untuk melakukan OFFSET
     */

    public function testPaging(){

        $this->insertTableProduct();

        // sql: select * from `categories` limit 2 offset 2
        $collection = DB::table("categories")
            ->skip(0) // OFFSET
            ->take(2) // LIMIT
            ->get();

        self::assertCount(2, $collection);
        $collection->each(function ($item){
            Log::info(json_encode($item));
        });

        var_dump($collection);

        /**
         * result:
         *
         * [2024-06-13 10:28:37] testing.INFO: select * from `categories` limit 2 offset 0
         * [2024-06-13 10:28:37] testing.INFO: {"id":"CELANA","name":"Celana","description":"","created_at":"2024-06-13 10:10:10"}
         * [2024-06-13 10:28:37] testing.INFO: {"id":"JAKET","name":"Jaket","description":"","created_at":"2024-06-13 10:10:10"}
         *
         * [2024-06-13 10:27:30] testing.INFO: select * from `categories` limit 2 offset 2
         * [2024-06-13 10:27:30] testing.INFO: {"id":"SANDAL","name":"Sandal","description":"","created_at":"2024-06-13 10:10:10"}
         * [2024-06-13 10:27:30] testing.INFO: {"id":"TOPI","name":"Topi","description":"","created_at":"2024-06-13 10:10:10"}
         */

    }

    /**
     * Chunk Result
     * ● Saat kita membuat aplikasi, kadang ada kasus kita mengelola data dengan ukuran besar
     * ● Secara default, semua query yang kita lakukan di Laravel, akan di load ke Memory sebagai
     *   Collection
     * ● Hal ini berbahaya ketika hasil query nya banyak, karena bisa berakibat terjadi error Out Of
     *   Memory
     * ● Dari pada kita me load semua data ke Memory, kita bisa memotong data hasil query secara
     *   bertahap menggunakan method chunk()
     * ● Implementasi chunk sebenarnya adalah dengan melakukan paging
     * ● Dan jika ingin menggunakan chunk, kita harus menambahkan ordering pada query nya
     */

    public function insertManyCategories()
    {
        for ($i = 0; $i < 100; $i++) {
            DB::table("categories")->insert([
                "id" => "CATEGORY-$i",
                "name" => "Category $i",
                "created_at" => "2024-06-13 21:53:10"
            ]);
        }
    }

    public function testChunk(){

        $this->insertManyCategories(); // insert dump 100

        // chunk  memotong data hasil query secara bertahap.. // skenario akan ambil setiap 10 data,
        // sql: select * from `categories` order by `id` asc limit 10 offset ~ n
        $data = DB::table("categories")
            ->orderBy("id")
            ->chunk(10, function ($categories){
               self::assertNotNull($categories);
               Log::info("Start Chunk");
                $categories->each(function ($category){
                   Log::info(json_encode($category));
                });
            });

        var_dump($data);

        /**
         * result: dia akan ambil data per 10, sudah ada limit 10 offset 10 juga
         * [2024-06-13 14:59:47] testing.INFO: select * from `categories` order by `id` asc limit 10 offset 0
         * [2024-06-13 14:59:47] testing.INFO: Start Chunk
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-0","name":"Category 0","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-1","name":"Category 1","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-10","name":"Category 10","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-11","name":"Category 11","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-12","name":"Category 12","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-13","name":"Category 13","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-14","name":"Category 14","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-15","name":"Category 15","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-16","name":"Category 16","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-17","name":"Category 17","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: select * from `categories` order by `id` asc limit 10 offset 10
         * [2024-06-13 14:59:47] testing.INFO: Start Chunk
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-18","name":"Category 18","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-19","name":"Category 19","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-2","name":"Category 2","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-20","name":"Category 20","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-21","name":"Category 21","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-22","name":"Category 22","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-23","name":"Category 23","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-24","name":"Category 24","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-25","name":"Category 25","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-26","name":"Category 26","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: select * from `categories` order by `id` asc limit 10 offset 20
         * [2024-06-13 14:59:47] testing.INFO: Start Chunk
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-27","name":"Category 27","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-28","name":"Category 28","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-29","name":"Category 29","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-3","name":"Category 3","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-30","name":"Category 30","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-31","name":"Category 31","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-32","name":"Category 32","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-33","name":"Category 33","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-34","name":"Category 34","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 14:59:47] testing.INFO: {"id":"CATEGORY-35","name":"Category 35","description":null,"created_at":"2024-06-13 21:53:10"}
         */

    }

    /**
     * Lazy Results
     * ● Menggunakan Chunk Results kadang menyulitkan, karena kita harus proses datanya secara
     *   manual per chunk
     * ● Untungnya Laravel memiliki fitur Lazy, dimana kita bisa menjadikan Query Builder dengan Lazy
     *   Results, yang menghasilkan Lazy Collection
     * ● Karena hasilnya berupa Lazy Collection, data yang diambil dari database akan bertahap, tidak
     *   langsung semuanya di load ke Memory
     * ● Implementasi detailnya sebenarnya tetap menggunakan Chunk Results
     */

    public function testLazy(){

        $this->insertManyCategories(); // insert dump 100

        // ambil data secara lazy
        // sql: select * from `categories` order by `id` asc limit 10 offset 0
        //$collection = DB::table("categories")
        //    ->orderBy("id", "asc")
        //    ->lazy(10);

        // ambil data secara lazy dan di limit
        // sql: select * from `categories` order by `id` asc limit 10 offset 0
        $collection = DB::table("categories")
            ->orderBy("id", "asc")
            ->lazy(10)
            ->take(3); // LIMIT

        assertNotNull($collection);

        $collection->each(function ($itam){
           Log::info(json_encode($itam));
        });

        var_dump($collection);

        /**
         * result: // ambil data secara lazy
         * [2024-06-13 15:06:52] testing.INFO: select * from `categories` order by `id` asc limit 10 offset 0
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-0","name":"Category 0","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-1","name":"Category 1","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-10","name":"Category 10","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-11","name":"Category 11","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-12","name":"Category 12","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-13","name":"Category 13","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-14","name":"Category 14","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-15","name":"Category 15","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-16","name":"Category 16","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-17","name":"Category 17","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: select * from `categories` order by `id` asc limit 10 offset 10
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-18","name":"Category 18","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-19","name":"Category 19","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-2","name":"Category 2","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-20","name":"Category 20","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-21","name":"Category 21","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-22","name":"Category 22","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-23","name":"Category 23","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-24","name":"Category 24","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-25","name":"Category 25","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-26","name":"Category 26","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: select * from `categories` order by `id` asc limit 10 offset 20
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-27","name":"Category 27","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-28","name":"Category 28","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-29","name":"Category 29","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-3","name":"Category 3","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-30","name":"Category 30","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-31","name":"Category 31","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-32","name":"Category 32","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-33","name":"Category 33","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-34","name":"Category 34","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:06:52] testing.INFO: {"id":"CATEGORY-35","name":"Category 35","description":null,"created_at":"2024-06-13 21:53:10"}
         *
         *
         * result: // ambil data secara lazy dan di limit
         * [2024-06-13 15:09:07] testing.INFO: select * from `categories` order by `id` asc limit 10 offset 0
         * [2024-06-13 15:09:07] testing.INFO: {"id":"CATEGORY-0","name":"Category 0","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:09:07] testing.INFO: {"id":"CATEGORY-1","name":"Category 1","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:09:07] testing.INFO: {"id":"CATEGORY-10","name":"Category 10","description":null,"created_at":"2024-06-13 21:53:10"}
         */

    }

    /**
     * Cursor
     * ● Selain Chunk dan Lazy, terdapat cara lain untuk membuat Lazy Result, yaitu menggunakan Cursor
     * ● Chunk dan Lazy sebenarnya melakukan paging dibelakang layar, sedangkan Cursor hanya akan
     *   melakukan query satu kali
     * ● Lalu akan mengambil datanya satu persatu menggunakan PDO::fetch()
     * ● Jadi secara penggunaan memory, Cursor akan lebih hemat dibanding dengan Chunk atau Lazy
     */

    public function testCursor(){

        $this->insertManyCategories(); // insert dump 100

        // sql: select * from `categories` order by `id` asc
        $collection = DB::table("categories")
            ->orderBy("id", "asc")
            ->cursor(); // cursor() // akan sekali query ke db dan data nya diambil satu - persatu

        self::assertNotNull($collection);

        $collection->each(function ($item){
           Log::info(json_encode($item));
        });

        var_dump($collection);

        /**
         * result:
         * [2024-06-13 15:17:05] testing.INFO: select * from `categories` order by `id` asc
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-0","name":"Category 0","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-1","name":"Category 1","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-10","name":"Category 10","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-11","name":"Category 11","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-12","name":"Category 12","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-13","name":"Category 13","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-14","name":"Category 14","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-15","name":"Category 15","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-16","name":"Category 16","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-17","name":"Category 17","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-18","name":"Category 18","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-19","name":"Category 19","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-2","name":"Category 2","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-20","name":"Category 20","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-21","name":"Category 21","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-22","name":"Category 22","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-23","name":"Category 23","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-24","name":"Category 24","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-25","name":"Category 25","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-26","name":"Category 26","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-27","name":"Category 27","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-28","name":"Category 28","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-29","name":"Category 29","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-3","name":"Category 3","description":null,"created_at":"2024-06-13 21:53:10"}
         * [2024-06-13 15:17:05] testing.INFO: {"id":"CATEGORY-30","name":"Category 30","description":null,"created_at":"2024-06-13 21:53:10"}
         */

    }

    /**
     * Query Builder Aggregate
     * ● Query Builder juga mendukung untuk melakukan Aggregate Query, kita bisa menggunakan
     * method :
     * ● count(column)      untuk jumlah data
     * ● min(column)        untuk minimal data
     * ● max(column)        untuk maksimal data
     * ● avg(column)        untuk rata-rata data
     * ● sum(column)        untuk menjumlahkan data
     */

    public function testAggregate(){

        $this->insertTableProduct();

        // note hasil bukan collection, jadi kita bisa olah datanya

        // sql: select count(`id`) as aggregate from `products`
        $result = DB::table("products")->count("id");
        self::assertEquals(2, $result);
        var_dump($result); // int(2)

        // sql: select min(`price`) as aggregate from `products`
        $result = DB::table("products")->min("price");
        self::assertEquals(90000, $result);
        var_dump($result); // int(90000)

        // sql: select max(`price`) as aggregate from `products`
        $result = DB::table("products")->max("price");
        self::assertEquals(100000, $result);
        var_dump($result); // int(100000)

        // sql: select avg(`price`) as aggregate from `products`
        $result = DB::table("products")->avg("price");
        self::assertEquals(95000, $result);
        var_dump($result); // string(10) "95000.0000"

        // sql: select sum(`price`) as aggregate from `products`
        $result = DB::table("products")->sum("price");
        self::assertEquals(190000, $result);
        var_dump($result); // string(6) "190000"


    }


}
